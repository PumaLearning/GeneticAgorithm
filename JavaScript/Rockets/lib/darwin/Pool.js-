class Pool {
  constructor(parents, maxFitness) {
    this.best = new Object({'fitness': 0})
    this.pool = []
    this.size = parents.length

    this.MUTATION_RATIO = 0.01

    for(let individual of parents)
      if(individual.bestFitness > this.best.fitness)
        this.best = individual

    for(let individual of parents) {
      let probabilities = Math.floor(map(individual.fitness, 0, this.best.fitness, 0, parents.length))
      for(let i = 0; i < probabilities; i++)
        this.pool.push(individual)
    }
  }

  offspring(empty) {
    let child = empty
    child.brain = this.pool[Math.floor(random() * this.pool.length)].brain.clone()
    child.brain.mutate(this.MUTATION_RATIO)
    
    return child
  }

  nextGeneration(_class) {
    let nextGen = []
    
    let superIndividual = new _class()
    superIndividual.c = color(0, 255, 0)
    superIndividual.brain = this.best.brain.clone()
    nextGen[0] = (superIndividual)

    for(let i = 1; i < this.size; i++)
      nextGen[i] = this.offspring(new _class())

    return nextGen
  }
}